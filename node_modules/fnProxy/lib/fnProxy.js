/*
 * fnProxy v 0.1 
 * by @flockonus
 * 
 * Prevents a function to be called before Xms. If another of the same call is made, then it is scheduled to Xms.
 * 
 * // works with anonymous function
 * t1 = new Date(); for(var i = 0; i < 10; i++ ){ fn( function(){ console.log(new Date() - t1) }, 100+i  )  };
 *   //=> 111
 * 
 * // also with 2 anonymous in parallel
 * t1 = new Date(); for(var i = 0; i < 10; i++ ){ fn( function(){ console.log(new Date() - t1) }, 100+i  )  }
 * for(var j = 0; j < 10; j++ ){ fn( function(){ console.info(new Date() - t1) }, 100*j+1  )  }
 *   //=> 111
 *   //=> 902
 * 
 * // But, if you use a named function..
 * function ab(){ console.log(new Date() - t1) }; 
 * t1 = new Date(); 
 * for(i = 0; i < 10; i++ ){ fn( ab, 100+i  )  };
 * for(var j = 0; j < 10; j++ ){ fn( ab, 100*j+1  )  };
 *   //=> 903
 * 
 */



// All functions we monitor
var fnTable = { }

function isArray( x ){
  return (typeof(x) == 'object' && x.shift && x.length && x.pop ? true : false )
}

function argsError(){
  throw( "ERROR: Params are: fn, timeout[, array_of_args, context ]" )
}


fnProxy = function( fn, timeout ){
  var args = Array.prototype.slice.call(arguments, 2)
  
  if( args.length <= 2 && fn && timeout ){
    // fist param, if present, must be a array. can be empty
    if( args[0] && !isArray(args) ) argsError()
    
    var fnParam = args.shift() || []
    var fnCtx = args.shift() || {}
    
    // not the first call
    if( fnTable[fn] ){
      clearTimeout( fnTable[fn] )
    }
    
    fnTable[fn] = setTimeout( 
      // if the timeout is done, and no other call has been made, execute.
      function(){
        fn.apply( fnCtx, fnParam )
        fnTable
      },
      timeout 
    )
    
    return true
  } else {
    argsError()
    return false
  }
  
  
}

module.exports = fnProxy